# ParkBoard - System Pseudocode & Refactoring Guide
**Generated:** 2025-10-07 09:07:52
**Purpose:** Human-readable pseudocode for entire system with refactoring recommendations

---

## Table of Contents

1. [System Overview](#system-overview)
2. [Database Layer](#database-layer)
3. [Authentication System](#authentication-system)
4. [Core Application Logic](#core-application-logic)
5. [User Interface Components](#user-interface-components)
6. [API Routes](#api-routes)
7. [Refactoring Recommendations](#refactoring-recommendations)
8. [Architecture Improvements](#architecture-improvements)

---

## System Overview

### System Architecture (Current State)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    NEXT.JS APP ROUTER                    â”‚
â”‚  (Server Components + Client Components)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                â”‚                â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
    â”‚ Browser â”‚      â”‚  Server â”‚     â”‚   API   â”‚
    â”‚ Client  â”‚      â”‚ Client  â”‚     â”‚  Routes â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚                â”‚                â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                   â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                   â”‚  SUPABASE   â”‚
                   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                   â”‚ PostgreSQL  â”‚
                   â”‚ + Auth      â”‚
                   â”‚ + RLS       â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User   â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   React UI     â”‚
â”‚ (Client Comp)  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Supabase       â”‚
â”‚ Client         â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RLS Policies   â”‚
â”‚ (Security)     â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PostgreSQL    â”‚
â”‚  (Data)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Database Layer

### Schema Design (Pseudocode)

```
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TABLE: user_profiles
// Purpose: Extends Supabase auth.users with business data
// Relations: 1-to-1 with auth.users, 1-to-many with parking_slots, bookings
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TABLE user_profiles {
  PRIMARY KEY: id (UUID)
    â†’ REFERENCES auth.users(id) CASCADE DELETE
    â†’ Design Decision: When auth user deleted, profile auto-deletes

  FIELDS:
    name: TEXT (required)
      â†’ Display name for UI
      â†’ Example: "John Doe"

    email: TEXT (required)
      â†’ Duplicate of auth.users.email for quick access
      â†’ Indexed for fast lookups

    phone: TEXT (required)
      â†’ Contact number, PH format: +639171234567 or 09171234567
      â†’ ğŸ”´ CRITICAL: No server-side validation currently
      â†’ âš ï¸ REFACTOR: Add CHECK constraint or validation function

    unit_number: TEXT (required)
      â†’ Condo unit identifier
      â†’ Example: "10A", "B-205"
      â†’ ğŸ”´ CRITICAL: Should be UNIQUE (one account per unit)
      â†’ âš ï¸ REFACTOR: Add UNIQUE constraint

    created_at: TIMESTAMPTZ (auto)
      â†’ Audit trail

  INDEXES:
    - idx_user_profiles_email ON (email)
      â†’ Fast login lookups

  RLS POLICIES:
    - "public_read_profiles" â†’ Anyone can read (needed for contact info)
    - "users_update_own_profile" â†’ Can only update own row
    - "users_insert_own_profile" â†’ Can only insert own row

  MISSING (TODO):
    - updated_at: TIMESTAMPTZ â†’ Track profile changes
    - role: TEXT â†’ 'user' or 'admin' for condo-owned slots
    - last_login_at: TIMESTAMPTZ â†’ Activity tracking
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TABLE: parking_slots
// Purpose: The "products" being rented
// Relations: Many-to-one with user_profiles (owner), 1-to-many with bookings
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TABLE parking_slots {
  PRIMARY KEY: slot_id (SERIAL)
    â†’ Auto-incrementing integer
    â†’ Design Decision: Use integer not UUID for simplicity

  FOREIGN KEYS:
    owner_id: UUID â†’ REFERENCES user_profiles(id) SET NULL
      â†’ Design Decision: SET NULL not CASCADE
      â†’ Why? Keep slot record even if owner account deleted
      â†’ NULL = condo-owned/admin-managed slot

  FIELDS:
    slot_number: TEXT (required, UNIQUE)
      â†’ Human-readable identifier
      â†’ Examples: "A-10", "B-5", "VISITOR-01"
      â†’ Enforced unique across all slots

    slot_type: TEXT (default: 'covered')
      â†’ Physical characteristic
      â†’ Values: 'covered', 'uncovered', 'tandem'
      â†’ ğŸŸ¡ REFACTOR: Add CHECK constraint for valid values

    description: TEXT (nullable)
      â†’ Optional details
      â†’ Examples: "Near elevator", "Well-lit corner spot"

    price_per_hour: DECIMAL(10,2) (required)
      â†’ Hourly rate in pesos
      â†’ CHECK: price_per_hour > 0
      â†’ âš ï¸ MISSING: No upper limit (could be abused)

    status: TEXT (default: 'active')
      â†’ Administrative status (NOT booking availability)
      â†’ Values: 'active', 'maintenance', 'disabled'
      â†’ CHECK: status IN (...)
      â†’ ğŸ”´ SCHEMA MISMATCH: Code uses 'is_available' (boolean)
      â†’ âš ï¸ REFACTOR NEEDED: Align code with schema

    created_at: TIMESTAMPTZ (auto)

  INDEXES:
    - idx_slots_status ON (status)
      â†’ Filter active slots quickly
    - idx_slots_owner ON (owner_id)
      â†’ "My slots" page for owners
    - idx_slots_available_combo ON (status, price_per_hour) WHERE status = 'active'
      â†’ Partial index for marketplace listings

  RLS POLICIES:
    - "public_read_slots" â†’ Anyone can browse marketplace
    - "owners_manage_own_slots" â†’ Full CRUD on own slots
    - "users_create_slots" â†’ Anyone can create (becomes owner)

  MISSING (TODO):
    - updated_at: TIMESTAMPTZ
    - Admin policy for owner_id IS NULL slots
    - Soft delete (deleted_at)
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TABLE: bookings
// Purpose: Junction table connecting users to slots with time ranges
// Relations: Many-to-one with parking_slots, user_profiles (renter)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TABLE bookings {
  PRIMARY KEY: booking_id (SERIAL)

  FOREIGN KEYS:
    slot_id: INT â†’ REFERENCES parking_slots(slot_id) CASCADE DELETE
      â†’ If slot deleted, bookings deleted too

    renter_id: UUID â†’ REFERENCES user_profiles(id) CASCADE DELETE
      â†’ If renter account deleted, bookings deleted
      â†’ ğŸŸ¡ REFACTOR: Consider SET NULL for historical data

  FIELDS:
    start_time: TIMESTAMPTZ (required)
      â†’ Booking start (UTC timezone)
      â†’ ğŸ”´ CRITICAL: Client must send UTC, not local time

    end_time: TIMESTAMPTZ (required)
      â†’ Booking end (UTC)
      â†’ CONSTRAINT: end_time > start_time

    total_price: DECIMAL(10,2) (required)
      â†’ Total cost = (hours) Ã— (slot.price_per_hour)
      â†’ CHECK: total_price > 0
      â†’ ğŸ”¥ HIGH PRIORITY: Should be auto-calculated by trigger
      â†’ âš ï¸ SECURITY RISK: Client can manipulate this value

    status: TEXT (default: 'pending')
      â†’ Lifecycle: pending â†’ confirmed â†’ completed/cancelled/no_show
      â†’ CHECK: status IN ('pending', 'confirmed', 'cancelled', 'completed', 'no_show')

    created_at: TIMESTAMPTZ (auto)

  CONSTRAINTS:
    - valid_time_range: CHECK (end_time > start_time)
      â†’ Prevent negative duration

    - no_overlap: EXCLUDE USING gist (
        slot_id WITH =,
        tstzrange(start_time, end_time) WITH &&
      ) WHERE (status != 'cancelled')
      â†’ Prevents double-booking
      â†’ Uses PostgreSQL range types + GiST index
      â†’ Excludes cancelled bookings (they don't block)

  INDEXES:
    - idx_bookings_slot ON (slot_id)
    - idx_bookings_renter ON (renter_id)
    - idx_bookings_status ON (status)
    - idx_bookings_time_range ON gist(tstzrange(start_time, end_time))
      â†’ Range overlap queries

  RLS POLICIES:
    - "users_see_relevant_bookings" â†’ See if you're renter OR slot owner
      â†’ ğŸ”´ PERFORMANCE ISSUE: Subquery executed per row
      â†’ âš ï¸ HIGH PRIORITY REFACTOR: Denormalize slot_owner_id

    - "users_create_bookings" â†’ Can create as renter
    - "renters_update_own_bookings" â†’ Renters can update own
    - "owners_update_slot_bookings" â†’ Owners can update bookings for their slots

  MISSING (TODO):
    - updated_at: TIMESTAMPTZ
    - slot_owner_id: UUID (denormalized from parking_slots.owner_id)
      â†’ Eliminates subquery in RLS policy (40-60% performance gain)
    - cancelled_at: TIMESTAMPTZ (audit trail)
    - cancellation_reason: TEXT
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FUNCTION is_slot_bookable(
  p_slot_id INT,
  p_start_time TIMESTAMPTZ,
  p_end_time TIMESTAMPTZ
) RETURNS BOOLEAN {
  // Check 1: Slot exists and is active
  slot_status = SELECT status FROM parking_slots WHERE slot_id = p_slot_id

  IF slot_status IS NULL THEN
    RETURN FALSE  // Slot doesn't exist
  END IF

  IF slot_status != 'active' THEN
    RETURN FALSE  // Slot in maintenance or disabled
  END IF

  // Check 2: No conflicting bookings
  conflict_count = COUNT(*) FROM bookings
    WHERE slot_id = p_slot_id
      AND status = 'confirmed'
      AND tstzrange(start_time, end_time) OVERLAPS tstzrange(p_start_time, p_end_time)

  RETURN conflict_count == 0
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROPOSED TRIGGERS (High Priority Refactor)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TRIGGER booking_set_owner BEFORE INSERT ON bookings {
  // Auto-populate slot_owner_id from parking_slots
  NEW.slot_owner_id = (
    SELECT owner_id FROM parking_slots WHERE slot_id = NEW.slot_id
  )
  RETURN NEW
}

TRIGGER booking_price_calculation BEFORE INSERT/UPDATE ON bookings {
  // Auto-calculate total_price
  slot_price = SELECT price_per_hour FROM parking_slots WHERE slot_id = NEW.slot_id
  duration_hours = EXTRACT(EPOCH FROM (NEW.end_time - NEW.start_time)) / 3600
  NEW.total_price = slot_price Ã— duration_hours
  RETURN NEW
}

TRIGGER update_updated_at BEFORE UPDATE ON {user_profiles, parking_slots, bookings} {
  NEW.updated_at = NOW()
  RETURN NEW
}
```

---

## Authentication System

### AuthWrapper Component (Pseudocode)

```typescript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPONENT: AuthWrapper
// File: components/auth/AuthWrapper.tsx
// Purpose: Global authentication state provider
// Usage: Wraps protected pages to enforce auth requirements
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

COMPONENT AuthWrapper(children: ReactNode) {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STATE MANAGEMENT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  STATE user: User | null = null
    // Supabase auth user (email, id, metadata)
    // Populated from auth.users table

  STATE profile: UserProfile | null = null
    // Business data from user_profiles table
    // Contains: name, phone, unit_number

  STATE loading: boolean = true
    // Prevents premature "not logged in" flash

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INITIALIZATION (On Component Mount)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ON_MOUNT {
    TRY {
      // Step 1: Check if session exists (local storage)
      session = AWAIT supabase.auth.getSession()

      // Step 2: Update user state
      SET user = session?.user || null

      // Step 3: If user exists, fetch profile
      IF session?.user THEN
        profileData = AWAIT supabase
          .from('user_profiles')
          .select('*')
          .eq('id', session.user.id)
          .single()

        SET profile = profileData
      END IF

    } CATCH (error) {
      LOG error
      // Don't crash, just show login page

    } FINALLY {
      SET loading = false
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SETUP AUTH STATE LISTENER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    subscription = supabase.auth.onAuthStateChange((event, session) => {
      SWITCH event {
        CASE 'SIGNED_OUT':
          SET user = null
          SET profile = null
          NAVIGATE_TO('/login')

        CASE 'SIGNED_IN':
          SET user = session.user

          // Fetch fresh profile
          profileData = AWAIT supabase
            .from('user_profiles')
            .select('*')
            .eq('id', session.user.id)
            .single()

          SET profile = profileData

        CASE 'TOKEN_REFRESHED':
          // Token auto-refreshed by Supabase
          SET user = session.user
          // No need to refetch profile (doesn't change on refresh)
      }
    })

    // CLEANUP: Unsubscribe when component unmounts
    RETURN () => subscription.unsubscribe()
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RENDER LOGIC (Guard Clauses Pattern)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Guard 1: Still loading
  IF loading THEN
    RENDER <LoadingSpinner />
  END IF

  // Guard 2: No user (unauthenticated)
  IF !user THEN
    NAVIGATE_TO('/login')
    RENDER <RedirectMessage>Redirecting to login...</RedirectMessage>
  END IF

  // Guard 3: User exists but no profile
  // ğŸ”´ EDGE CASE: Auth user without profile (orphaned record)
  // âš ï¸ TODO: Better error handling
  IF !profile THEN
    RENDER <LoadingSpinner message="Loading profile..." />
  END IF

  // Success: All checks passed
  RENDER (
    <AuthContext.Provider value={{ user, profile, loading }}>
      {children}
    </AuthContext.Provider>
  )
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HOOK: useAuth
// Purpose: Access auth context from any component
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

HOOK useAuth() {
  context = useContext(AuthContext)

  IF context === undefined THEN
    THROW ERROR "useAuth must be used within AuthWrapper"
  END IF

  RETURN context  // { user, profile, loading }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REFACTORING RECOMMENDATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”¥ HIGH PRIORITY REFACTORS:

1. Handle orphaned auth users (user without profile)
   CURRENT: Shows "Loading profile..." forever
   FIX: Redirect to /profile/complete with form to create profile

2. Add error state for profile fetch failure
   CURRENT: Silent failure, loading forever
   FIX: Show error message with retry button

3. Implement session expiry warning
   CURRENT: User loses work when session expires
   FIX: Show toast 5 minutes before expiry

4. Cache profile data
   CURRENT: Refetches on every SIGNED_IN event
   FIX: Only refetch on profile update

5. Add middleware protection
   CURRENT: Client-side redirect only (can bypass)
   FIX: Create middleware.ts to check auth server-side

PSEUDOCODE for middleware.ts:
  MIDDLEWARE check_auth(request) {
    session = AWAIT supabase.auth.getSession()

    IF !session AND request.path != '/login' THEN
      RETURN REDIRECT('/login')
    END IF

    IF session AND request.path == '/login' THEN
      RETURN REDIRECT('/slots')
    END IF

    RETURN NEXT()
  }
```

### Login Flow (Pseudocode)

```typescript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PAGE: Login
// File: app/(auth)/login/page.tsx
// Purpose: User authentication entry point
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PAGE LoginPage() {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STATE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  STATE email: string = ''
  STATE password: string = ''
  STATE error: string | null = null
  STATE loading: boolean = false

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HANDLER: Submit Login
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ASYNC FUNCTION handleLogin(event) {
    event.preventDefault()  // Prevent page reload

    SET loading = true
    SET error = null

    TRY {
      // Step 1: Call Supabase auth
      result = AWAIT supabase.auth.signInWithPassword({
        email: email,
        password: password
      })

      // Step 2: Check for errors
      IF result.error THEN
        SET error = result.error.message
        RETURN
      END IF

      // Step 3: Success - session auto-stored in cookie
      // AuthWrapper will detect SIGNED_IN event and fetch profile
      NAVIGATE_TO('/slots')

    } CATCH (err) {
      SET error = "Login failed. Please try again."

    } FINALLY {
      SET loading = false
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RENDER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  RENDER (
    <Card>
      <Form onSubmit={handleLogin}>
        <Input
          type="email"
          value={email}
          onChange={(e) => SET email = e.target.value}
          required
        />

        <Input
          type="password"
          value={password}
          onChange={(e) => SET password = e.target.value}
          required
        />

        {error && <Alert variant="error">{error}</Alert>}

        <Button type="submit" disabled={loading}>
          {loading ? "Logging in..." : "Login"}
        </Button>
      </Form>
    </Card>
  )
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REFACTORING RECOMMENDATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”¥ HIGH PRIORITY:

1. Add rate limiting
   CURRENT: No protection against brute force
   FIX: Implement Upstash Rate Limit (5 attempts per hour per IP)

2. Add client-side validation
   CURRENT: Only browser HTML5 validation
   FIX: Custom validation with error messages

3. Add "Remember Me" option
   CURRENT: Session expires after 1 hour
   FIX: Option for longer session (7 days)

4. Add password reset link
   CURRENT: No way to recover forgotten password
   FIX: Link to /reset-password page

5. Add OAuth providers
   CURRENT: Email/password only
   FIX: Add Google, Facebook sign-in

PSEUDOCODE for rate limiting:
  BEFORE handleLogin() {
    ip = request.ip
    attempts = GET_FROM_REDIS(`login_attempts:${ip}`)

    IF attempts >= 5 THEN
      THROW ERROR "Too many login attempts. Try again in 1 hour."
    END IF

    INCREMENT_REDIS(`login_attempts:${ip}`, expire: 3600)
  }
```

### Registration Flow (Pseudocode)

```typescript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PAGE: Register
// File: app/(auth)/register/page.tsx
// Purpose: New user account creation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PAGE RegisterPage() {
  STATE formData = {
    name: '',
    email: '',
    password: '',
    phone: '',
    unit_number: ''
  }
  STATE error: string | null = null
  STATE loading: boolean = false

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HANDLER: Submit Registration
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ASYNC FUNCTION handleRegister(event) {
    event.preventDefault()

    SET loading = true
    SET error = null

    TRY {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 1: Validate input (client-side)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      IF !validatePhoneNumber(formData.phone) THEN
        SET error = "Invalid phone number. Use +639XXXXXXXXX format."
        RETURN
      END IF

      IF formData.password.length < 8 THEN
        SET error = "Password must be at least 8 characters."
        RETURN
      END IF

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 2: Create auth user
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      authResult = AWAIT supabase.auth.signUp({
        email: formData.email,
        password: formData.password
      })

      IF authResult.error THEN
        SET error = authResult.error.message
        RETURN
      END IF

      userId = authResult.data.user.id

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 3: Create user profile
      // ğŸ”´ CRITICAL: Manual transaction (no rollback on failure)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      profileResult = AWAIT fetch('/api/profiles', {
        method: 'POST',
        body: JSON.stringify({
          id: userId,
          name: formData.name,
          email: formData.email,
          phone: formData.phone,
          unit_number: formData.unit_number
        })
      })

      IF !profileResult.ok THEN
        // âš ï¸ PROBLEM: Auth user already created, but profile failed
        // âš ï¸ TODO: Delete auth user or show error to retry
        SET error = "Failed to create profile. Please contact support."
        RETURN
      END IF

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 4: Auto-login (sign in with credentials)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      AWAIT supabase.auth.signInWithPassword({
        email: formData.email,
        password: formData.password
      })

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 5: Redirect to marketplace
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      NAVIGATE_TO('/slots')

    } CATCH (err) {
      SET error = "Registration failed. Please try again."

    } FINALLY {
      SET loading = false
    }
  }

  // RENDER: Form with all fields...
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API ROUTE: Create Profile
// File: app/api/profiles/route.ts
// Purpose: Server-side profile creation with validation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

API POST /api/profiles (request) {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STEP 1: Parse request body
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  { id, name, email, phone, unit_number } = PARSE request.body

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STEP 2: Validate required fields
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  IF !id OR !name OR !phone OR !unit_number THEN
    RETURN ERROR(400, "Missing required fields")
  END IF

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STEP 3: Validate phone format (server-side)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  phoneRegex = /^(\+63|0)\d{10}$/
  IF !phoneRegex.test(phone) THEN
    RETURN ERROR(400, "Invalid phone number format")
  END IF

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STEP 4: Check for duplicate unit number
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  existingUnit = AWAIT supabase
    .from('user_profiles')
    .select('id')
    .eq('unit_number', unit_number)
    .single()

  IF existingUnit THEN
    RETURN ERROR(409, "Unit number already registered")
  END IF

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STEP 5: Insert profile
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  result = AWAIT supabase
    .from('user_profiles')
    .insert({
      id: id,
      name: name,
      email: email,
      phone: phone,
      unit_number: unit_number
    })

  IF result.error THEN
    RETURN ERROR(500, result.error.message)
  END IF

  RETURN SUCCESS(200, { success: true })
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REFACTORING RECOMMENDATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”´ CRITICAL ISSUES:

1. No proper transaction handling
   PROBLEM: If profile creation fails, auth user is orphaned
   FIX OPTIONS:
     A) Delete auth user if profile fails (requires admin client)
     B) Use database trigger to auto-create profile
     C) Show error with "Complete Profile" flow

   RECOMMENDED FIX (Option B):
     CREATE TRIGGER auto_create_profile AFTER INSERT ON auth.users {
       INSERT INTO user_profiles (id, email, created_at)
       VALUES (NEW.id, NEW.email, NOW())
       ON CONFLICT (id) DO NOTHING
     }

     Then registration page only needs to UPDATE profile with name/phone/unit

2. No email verification
   PROBLEM: Anyone can register with any email
   FIX: Disable auto-confirm in Supabase, add verification flow

   PSEUDOCODE:
     authResult = AWAIT supabase.auth.signUp({
       email: email,
       password: password,
       options: {
         emailRedirectTo: 'https://parkboard.com/verify-email'
       }
     })

     // Show message: "Check your email to verify"
     // Don't create profile or login until verified

3. No password strength requirements
   PROBLEM: Users can set weak passwords
   FIX: Add strength meter and requirements

4. Unit number not unique
   PROBLEM: Multiple users can claim same unit
   FIX: Add UNIQUE constraint to unit_number column
```

---

## Core Application Logic

### Slots Listing Page (Pseudocode)

```typescript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PAGE: Browse Slots
// File: app/(marketplace)/slots/page.tsx
// Purpose: Marketplace listing of available parking slots
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PAGE SlotsPage() {
  // Wrapped in AuthWrapper (protected route)

  STATE slots: Slot[] = []
  STATE loading: boolean = true
  STATE error: string | null = null

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FETCH SLOTS ON MOUNT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ON_MOUNT {
    TRY {
      // Query with join to get owner info
      result = AWAIT supabase
        .from('parking_slots')
        .select(`
          slot_id,
          slot_number,
          slot_type,
          description,
          price_per_hour,
          status,
          user_profiles (
            name,
            phone
          )
        `)
        .eq('status', 'active')  // ğŸ”´ SCHEMA MISMATCH: Should be 'status' not 'is_available'
        .order('created_at', { ascending: false })

      IF result.error THEN
        THROW result.error
      END IF

      SET slots = result.data

    } CATCH (err) {
      SET error = err.message

    } FINALLY {
      SET loading = false
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RENDER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  IF loading THEN
    RENDER <LoadingSpinner />
  END IF

  IF error THEN
    RENDER <ErrorDisplay message={error} />
  END IF

  IF slots.length == 0 THEN
    RENDER <EmptyState>
      <Text>No slots available. Be the first to list one!</Text>
      <Button href="/slots/new">List Your Slot</Button>
    </EmptyState>
  END IF

  RENDER (
    <Container>
      <Header>
        <Title>Available Parking Slots</Title>
        <Button href="/slots/new">List Your Slot</Button>
      </Header>

      <Grid columns={3}>
        {slots.map(slot => (
          <SlotCard
            key={slot.slot_id}
            slot={slot}
            onClick={() => NAVIGATE_TO(`/slots/${slot.slot_id}`)}
          />
        ))}
      </Grid>
    </Container>
  )
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPONENT: SlotCard
// Purpose: Individual slot display in grid
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

COMPONENT SlotCard({ slot, onClick }) {
  RENDER (
    <Card clickable onClick={onClick}>
      <CardHeader>
        <SlotNumber>Slot {slot.slot_number}</SlotNumber>
        <Price>â‚±{slot.price_per_hour}/hr</Price>
      </CardHeader>

      <CardContent>
        <SlotType>{slot.slot_type}</SlotType>

        {slot.description && (
          <Description>{slot.description}</Description>
        )}

        <OwnerInfo>
          Owner: {slot.user_profiles.name}
        </OwnerInfo>

        <Button>Book Now</Button>
      </CardContent>
    </Card>
  )
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REFACTORING RECOMMENDATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”´ CRITICAL:

1. Schema mismatch - status vs is_available
   CURRENT CODE: .eq('is_available', true)
   SCHEMA HAS: status column ('active', 'maintenance', 'disabled')
   FIX: .eq('status', 'active')

ğŸ”¥ HIGH PRIORITY:

2. Add search/filter functionality
   CURRENT: Shows all slots, no filtering
   FIX: Add filters for:
     - Price range
     - Slot type
     - Location/slot number

   PSEUDOCODE:
     STATE filters = {
       minPrice: null,
       maxPrice: null,
       slotType: 'all'
     }

     FUNCTION applyFilters(slots) {
       RETURN slots.filter(slot => {
         IF filters.minPrice AND slot.price_per_hour < filters.minPrice THEN
           RETURN false
         END IF

         IF filters.maxPrice AND slot.price_per_hour > filters.maxPrice THEN
           RETURN false
         END IF

         IF filters.slotType != 'all' AND slot.slot_type != filters.slotType THEN
           RETURN false
         END IF

         RETURN true
       })
     }

3. Add pagination
   CURRENT: Loads all slots at once
   PROBLEM: Will be slow with 1000+ slots
   FIX: Implement pagination or infinite scroll

   PSEUDOCODE:
     STATE page = 1
     CONST ITEMS_PER_PAGE = 20

     FUNCTION fetchSlots(page) {
       result = AWAIT supabase
         .from('parking_slots')
         .select('*')
         .eq('status', 'active')
         .range((page - 1) * ITEMS_PER_PAGE, page * ITEMS_PER_PAGE - 1)

       RETURN result.data
     }

4. Add availability indicator
   CURRENT: Shows all "active" slots, but some may be booked
   FIX: Check for current/upcoming bookings

   PSEUDOCODE:
     FUNCTION isAvailableNow(slotId) {
       conflicts = AWAIT supabase
         .from('bookings')
         .select('booking_id')
         .eq('slot_id', slotId)
         .eq('status', 'confirmed')
         .gte('end_time', NOW())
         .lte('start_time', NOW())

       RETURN conflicts.length == 0
     }

5. Optimize query performance
   CURRENT: Fetches owner info via join (N+1 query potential)
   FIX: Use covering index or denormalize owner name

   See optimizations doc: idx_slots_listing (covering index)
```

### Slot Detail & Booking Page (Pseudocode)

```typescript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PAGE: Book a Slot
// File: app/(marketplace)/slots/[slotId]/page.tsx
// Purpose: Display slot details and create booking
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PAGE BookSlotPage({ params }) {
  slotId = params.slotId
  { user } = useAuth()

  STATE slot: SlotDetails | null = null
  STATE startTime: string = ''
  STATE endTime: string = ''
  STATE totalPrice: number = 0
  STATE loading: boolean = true
  STATE submitting: boolean = false
  STATE error: string | null = null
  STATE success: boolean = false

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FETCH SLOT DETAILS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ON_MOUNT {
    TRY {
      result = AWAIT supabase
        .from('parking_slots')
        .select(`
          slot_id,
          slot_number,
          slot_type,
          description,
          price_per_hour,
          status,
          user_profiles (
            name,
            phone
          )
        `)
        .eq('slot_id', slotId)
        .single()

      IF result.error THEN
        THROW result.error
      END IF

      IF result.data.status != 'active' THEN
        THROW ERROR "This slot is not available for booking"
      END IF

      SET slot = result.data

    } CATCH (err) {
      SET error = err.message

    } FINALLY {
      SET loading = false
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CALCULATE PRICE (Live Update)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ON_CHANGE [startTime, endTime, slot] {
    IF !startTime OR !endTime OR !slot THEN
      RETURN
    END IF

    start = new Date(startTime)
    end = new Date(endTime)

    IF end <= start THEN
      SET totalPrice = 0
      RETURN
    END IF

    hours = (end - start) / (1000 * 60 * 60)
    price = hours * slot.price_per_hour

    SET totalPrice = ROUND(price, 2)
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SUBMIT BOOKING
  // ğŸ”´ CRITICAL: No server-side price validation
  // ğŸ”´ CRITICAL: Client can manipulate total_price
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ASYNC FUNCTION handleBook(event) {
    event.preventDefault()

    SET submitting = true
    SET error = null

    TRY {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // VALIDATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      start = new Date(startTime)
      end = new Date(endTime)

      IF end <= start THEN
        THROW ERROR "End time must be after start time"
      END IF

      IF start < new Date() THEN
        THROW ERROR "Start time must be in the future"
      END IF

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CHECK FOR CONFLICTS (Optional - DB constraint will catch)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      conflicts = AWAIT supabase
        .from('bookings')
        .select('booking_id')
        .eq('slot_id', slotId)
        .eq('status', 'confirmed')
        .or(`start_time.lte.${endTime},end_time.gte.${startTime}`)

      IF conflicts.data.length > 0 THEN
        THROW ERROR "Slot already booked for this time"
      END IF

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // INSERT BOOKING
      // âš ï¸ SECURITY ISSUE: Client provides total_price (can be manipulated)
      // âš ï¸ TODO: Price should be calculated server-side
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      result = AWAIT supabase
        .from('bookings')
        .insert({
          slot_id: slotId,
          renter_id: user.id,
          start_time: startTime,
          end_time: endTime,
          total_price: totalPrice,  // ğŸ”´ VULNERABLE: User can modify this
          status: 'pending'
        })
        .select()
        .single()

      IF result.error THEN
        THROW result.error
      END IF

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SUCCESS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      SET success = true

      WAIT 2000  // Show success message
      NAVIGATE_TO('/bookings')

    } CATCH (err) {
      SET error = err.message

    } FINALLY {
      SET submitting = false
    }
  }

  // RENDER: Form with slot details and booking inputs...
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REFACTORING RECOMMENDATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”´ CRITICAL SECURITY ISSUES:

1. Client-side price calculation (EXPLOITABLE)
   PROBLEM: User can open DevTools, modify totalPrice before submit

   EXAMPLE EXPLOIT:
     // In browser console:
     totalPrice = 0.01  // Pay 1 cent for 8-hour booking!

   FIX: Add database trigger to auto-calculate price

   TRIGGER booking_price_calculation BEFORE INSERT ON bookings {
     slot_price = SELECT price_per_hour FROM parking_slots
                  WHERE slot_id = NEW.slot_id

     duration_hours = EXTRACT(EPOCH FROM (NEW.end_time - NEW.start_time)) / 3600

     NEW.total_price = slot_price * duration_hours

     RETURN NEW
   }

   Then in client code:
     // Don't send total_price, let trigger calculate it
     result = AWAIT supabase
       .from('bookings')
       .insert({
         slot_id, renter_id, start_time, end_time, status: 'pending'
         // total_price calculated by trigger
       })

ğŸ”¥ HIGH PRIORITY:

2. Add availability calendar view
   CURRENT: User picks dates blindly, might conflict
   FIX: Show calendar with booked times grayed out

   PSEUDOCODE:
     FUNCTION fetchBookedTimes(slotId) {
       bookings = AWAIT supabase
         .from('bookings')
         .select('start_time, end_time')
         .eq('slot_id', slotId)
         .eq('status', 'confirmed')
         .gte('end_time', NOW())

       RETURN bookings.map(b => ({
         start: new Date(b.start_time),
         end: new Date(b.end_time)
       }))
     }

     COMPONENT CalendarView({ bookedTimes }) {
       // Render calendar with booked times highlighted
     }

3. Add instant booking confirmation (skip pending state)
   CURRENT: Booking goes to "pending", owner must confirm
   FIX: Auto-confirm if slot available

   PSEUDOCODE:
     result = AWAIT supabase
       .from('bookings')
       .insert({
         ...bookingData,
         status: 'confirmed'  // Skip pending
       })

4. Add email/SMS notification to owner
   CURRENT: Owner doesn't know about new booking
   FIX: Trigger notification on booking creation

   See Database Layer: notify_new_booking trigger
```

### My Bookings Page (Pseudocode)

```typescript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PAGE: My Bookings
// File: app/(marketplace)/bookings/page.tsx
// Purpose: Display user's booking history
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PAGE BookingsPage() {
  { user } = useAuth()

  STATE bookings: Booking[] = []
  STATE loading: boolean = true
  STATE error: string | null = null

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FETCH USER'S BOOKINGS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ON_MOUNT {
    TRY {
      result = AWAIT supabase
        .from('bookings')
        .select(`
          booking_id,
          start_time,
          end_time,
          total_price,
          status,
          created_at,
          parking_slots (
            slot_number,
            user_profiles (
              name,
              phone
            )
          )
        `)
        .eq('renter_id', user.id)
        .order('created_at', { ascending: false })

      IF result.error THEN
        THROW result.error
      END IF

      SET bookings = result.data

    } CATCH (err) {
      SET error = err.message

    } FINALLY {
      SET loading = false
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CANCEL BOOKING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ASYNC FUNCTION handleCancel(bookingId) {
    // Show confirmation dialog
    confirmed = CONFIRM("Are you sure you want to cancel this booking?")

    IF !confirmed THEN
      RETURN
    END IF

    TRY {
      result = AWAIT supabase
        .from('bookings')
        .update({ status: 'cancelled' })
        .eq('booking_id', bookingId)
        .eq('renter_id', user.id)  // RLS will enforce, but explicit is good

      IF result.error THEN
        THROW result.error
      END IF

      // Update local state (optimistic update)
      SET bookings = bookings.map(b =>
        b.booking_id === bookingId
          ? { ...b, status: 'cancelled' }
          : b
      )

    } CATCH (err) {
      ALERT("Failed to cancel booking: " + err.message)
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HELPER: Get Status Badge Color
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  FUNCTION getStatusColor(status) {
    SWITCH status {
      CASE 'pending': RETURN 'yellow'
      CASE 'confirmed': RETURN 'green'
      CASE 'cancelled': RETURN 'red'
      CASE 'completed': RETURN 'blue'
      CASE 'no_show': RETURN 'gray'
      DEFAULT: RETURN 'gray'
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RENDER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  IF loading THEN
    RENDER <LoadingSpinner />
  END IF

  IF error THEN
    RENDER <ErrorDisplay message={error} />
  END IF

  IF bookings.length == 0 THEN
    RENDER <EmptyState>
      <Text>You haven't made any bookings yet.</Text>
      <Button href="/slots">Browse Available Slots</Button>
    </EmptyState>
  END IF

  RENDER (
    <Container>
      <Title>My Bookings</Title>

      <BookingsList>
        {bookings.map(booking => (
          <BookingCard key={booking.booking_id}>
            <Header>
              <SlotNumber>Slot {booking.parking_slots.slot_number}</SlotNumber>
              <StatusBadge color={getStatusColor(booking.status)}>
                {booking.status.toUpperCase()}
              </StatusBadge>
            </Header>

            <Details>
              <Row>
                <Label>Booking ID</Label>
                <Value>#{booking.booking_id}</Value>
              </Row>

              <Row>
                <Label>Start Time</Label>
                <Value>{formatDateTime(booking.start_time)}</Value>
              </Row>

              <Row>
                <Label>End Time</Label>
                <Value>{formatDateTime(booking.end_time)}</Value>
              </Row>

              <Row>
                <Label>Total Price</Label>
                <Value>â‚±{booking.total_price.toFixed(2)}</Value>
              </Row>

              <OwnerContact>
                <Label>Owner Contact</Label>
                <Name>{booking.parking_slots.user_profiles.name}</Name>
                <Phone>{booking.parking_slots.user_profiles.phone}</Phone>
              </OwnerContact>
            </Details>

            {booking.status == 'pending' && (
              <Actions>
                <Button
                  variant="outline"
                  onClick={() => handleCancel(booking.booking_id)}
                >
                  Cancel Booking
                </Button>
              </Actions>
            )}
          </BookingCard>
        ))}
      </BookingsList>
    </Container>
  )
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REFACTORING RECOMMENDATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”¥ HIGH PRIORITY:

1. Add owner view (bookings for my slots)
   CURRENT: Only shows bookings where user is renter
   FIX: Add tab to show bookings where user owns the slot

   PSEUDOCODE:
     TABS {
       TAB "My Rentals" {
         // Current view (user is renter)
         bookings WHERE renter_id = user.id
       }

       TAB "My Slots' Bookings" {
         // New view (user is owner)
         bookings WHERE slot_id IN (
           SELECT slot_id FROM parking_slots WHERE owner_id = user.id
         )
       }
     }

2. Add booking status actions for owners
   CURRENT: Only renters can cancel
   FIX: Owners can confirm/reject pending bookings

   PSEUDOCODE:
     IF user.id == booking.slot_owner_id THEN
       SHOW <Button onClick={confirmBooking}>Confirm</Button>
       SHOW <Button onClick={rejectBooking}>Reject</Button>
     END IF

3. Add refund policy handling
   CURRENT: Cancellation has no time restrictions or penalties
   FIX: Implement cancellation policy

   PSEUDOCODE:
     FUNCTION canCancelBooking(booking) {
       hoursUntilStart = (booking.start_time - NOW()) / (1000 * 60 * 60)

       IF hoursUntilStart < 24 THEN
         RETURN {
           canCancel: true,
           refund: 0.5,  // 50% refund if cancelled < 24h before
           message: "Cancelling within 24 hours: 50% refund"
         }
       ELSE
         RETURN {
           canCancel: true,
           refund: 1.0,  // Full refund if > 24h before
           message: "Full refund available"
         }
       END IF
     }

4. Add filters/sorting
   CURRENT: All bookings mixed together
   FIX: Filter by status, sort by date

   PSEUDOCODE:
     STATE filter = 'all'  // all, pending, confirmed, completed, cancelled

     filteredBookings = bookings.filter(b =>
       filter == 'all' OR b.status == filter
     )
```

### List New Slot Page (Pseudocode)

```typescript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PAGE: List New Slot
// File: app/(marketplace)/slots/new/page.tsx
// Purpose: Create new parking slot listing
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PAGE NewSlotPage() {
  { user } = useAuth()

  STATE formData = {
    slot_number: '',
    slot_type: 'covered',
    description: '',
    price_per_hour: ''
  }
  STATE loading: boolean = false
  STATE error: string | null = null

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SUBMIT NEW SLOT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ASYNC FUNCTION handleSubmit(event) {
    event.preventDefault()

    SET loading = true
    SET error = null

    TRY {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // VALIDATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      IF !formData.slot_number.trim() THEN
        THROW ERROR "Slot number is required"
      END IF

      pricePerHour = parseFloat(formData.price_per_hour)

      IF isNaN(pricePerHour) OR pricePerHour <= 0 THEN
        THROW ERROR "Price must be greater than 0"
      END IF

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // INSERT SLOT
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      result = AWAIT supabase
        .from('parking_slots')
        .insert({
          owner_id: user.id,
          slot_number: formData.slot_number.trim().toUpperCase(),
          slot_type: formData.slot_type,
          description: formData.description.trim() || null,
          price_per_hour: pricePerHour,
          status: 'active'  // ğŸ”´ SCHEMA: Use 'status' not 'is_available'
        })
        .select()
        .single()

      IF result.error THEN
        // Handle duplicate slot number (unique constraint)
        IF result.error.code == '23505' THEN
          THROW ERROR "This slot number already exists. Please use a different number."
        END IF

        THROW result.error
      END IF

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SUCCESS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      NAVIGATE_TO('/slots')

    } CATCH (err) {
      SET error = err.message

    } FINALLY {
      SET loading = false
    }
  }

  // RENDER: Form with all inputs...
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REFACTORING RECOMMENDATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”¥ HIGH PRIORITY:

1. Add photo upload
   CURRENT: No way to add slot photos
   FIX: Integrate Supabase Storage for images

   PSEUDOCODE:
     ASYNC FUNCTION uploadPhoto(file) {
       { data, error } = AWAIT supabase.storage
         .from('slot-photos')
         .upload(`${user.id}/${Date.now()}_${file.name}`, file)

       IF error THEN THROW error

       // Get public URL
       publicURL = supabase.storage
         .from('slot-photos')
         .getPublicUrl(data.path)

       RETURN publicURL
     }

     // Add to parking_slots table:
     ALTER TABLE parking_slots ADD COLUMN photo_url TEXT

2. Add location/floor information
   CURRENT: Only slot number, no location details
   FIX: Add floor, section, distance to elevator, etc.

   SCHEMA CHANGE:
     ALTER TABLE parking_slots ADD COLUMN floor TEXT
     ALTER TABLE parking_slots ADD COLUMN section TEXT
     ALTER TABLE parking_slots ADD COLUMN distance_to_elevator INT  // meters

3. Add availability schedule (advanced)
   CURRENT: Slot always available (if not booked)
   FIX: Allow owners to set unavailable periods

   NEW TABLE:
     CREATE TABLE slot_availability_overrides (
       id SERIAL PRIMARY KEY,
       slot_id INT REFERENCES parking_slots(slot_id),
       start_time TIMESTAMPTZ,
       end_time TIMESTAMPTZ,
       available BOOLEAN,
       reason TEXT,

       CONSTRAINT no_overlap EXCLUDE USING gist (
         slot_id WITH =,
         tstzrange(start_time, end_time) WITH &&
       )
     )

     // Usage: Owner can mark "Unavailable Dec 25-26 (using slot myself)"

4. Add pricing rules (dynamic pricing)
   CURRENT: Fixed price per hour
   FIX: Allow different prices for different times

   See optimizations doc: pricing_rules table
```

---

## User Interface Components

### Navigation Component (Pseudocode)

```typescript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPONENT: Navigation
// File: components/common/Navigation.tsx
// Purpose: Top navigation bar with user menu
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

COMPONENT Navigation() {
  { profile } = useAuth()
  supabase = createClient()

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SIGN OUT HANDLER
  // ğŸ”´ TODO: Not implemented yet
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ASYNC FUNCTION handleSignOut() {
    TRY {
      result = AWAIT supabase.auth.signOut()

      IF result.error THEN
        LOG error
        RETURN
      END IF

      // AuthWrapper's onAuthStateChange will catch SIGNED_OUT
      // and redirect to /login

    } CATCH (err) {
      LOG "Sign out failed:", err
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RENDER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  RENDER (
    <Nav>
      <LeftSection>
        <Logo href="/slots">ParkBoard</Logo>

        {/* ğŸ”´ TODO: Add navigation links */}
        <NavLinks>
          <NavLink href="/slots">Browse Slots</NavLink>
          <NavLink href="/slots/new">List My Slot</NavLink>
          <NavLink href="/bookings">My Bookings</NavLink>
        </NavLinks>
      </LeftSection>

      <RightSection>
        {/* ğŸ”´ TODO: Show user info */}
        <UserInfo>
          <UserName>{profile.name}</UserName>
          <UserUnit>Unit {profile.unit_number}</UserUnit>
        </UserInfo>

        {/* ğŸ”´ TODO: Add Sign Out button */}
        <Button variant="outline" onClick={handleSignOut}>
          Sign Out
        </Button>
      </RightSection>
    </Nav>
  )
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REFACTORING RECOMMENDATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”¥ HIGH PRIORITY:

1. Complete the TODOs
   - Implement handleSignOut âœ“ (pseudocode above)
   - Add navigation links âœ“
   - Show user info âœ“

2. Add mobile responsive menu
   CURRENT: Desktop-only layout
   FIX: Hamburger menu for mobile

   PSEUDOCODE:
     STATE menuOpen = false

     <MobileMenuButton onClick={() => menuOpen = !menuOpen}>
       â˜°
     </MobileMenuButton>

     {menuOpen && (
       <MobileMenu>
         <NavLink onClick={() => menuOpen = false}>Browse Slots</NavLink>
         <NavLink onClick={() => menuOpen = false}>List Slot</NavLink>
         <NavLink onClick={() => menuOpen = false}>Bookings</NavLink>
       </MobileMenu>
     )}

3. Add notification badge
   CURRENT: No indication of new bookings/messages
   FIX: Show count of pending actions

   PSEUDOCODE:
     STATE notificationCount = 0

     ON_MOUNT {
       // For slot owners: count pending bookings
       count = AWAIT supabase
         .from('bookings')
         .select('booking_id', { count: 'exact' })
         .eq('status', 'pending')
         .in('slot_id', (
           SELECT slot_id FROM parking_slots WHERE owner_id = user.id
         ))

       SET notificationCount = count
     }

     <NavLink href="/bookings">
       My Bookings
       {notificationCount > 0 && (
         <Badge>{notificationCount}</Badge>
       )}
     </NavLink>
```

---

## Refactoring Recommendations

### ğŸ”´ Critical Issues (Fix Before Production)

#### 1. Schema-Code Mismatch: status vs is_available

**Problem:**
- Schema uses `status` column ('active', 'maintenance', 'disabled')
- Code queries for `is_available` (boolean)
- Queries fail silently or return wrong results

**Affected Files:**
- `app/(marketplace)/slots/page.tsx:33`
- `app/(marketplace)/slots/new/page.tsx`

**Fix Option A: Update Code (Recommended)**
```typescript
// BEFORE (Wrong)
.eq('is_available', true)

// AFTER (Correct)
.eq('status', 'active')
```

**Fix Option B: Add Computed Column**
```sql
ALTER TABLE parking_slots
ADD COLUMN is_available BOOLEAN
GENERATED ALWAYS AS (status = 'active') STORED;

CREATE INDEX idx_slots_is_available ON parking_slots(is_available);
```

---

#### 2. Client-Side Price Calculation (Security Vulnerability)

**Problem:**
- Client calculates `total_price` and sends to database
- User can modify value in DevTools before submit
- Pay $0.01 for any booking!

**Affected Files:**
- `app/(marketplace)/slots/[slotId]/page.tsx`
- `db/schema_refined.sql` (missing trigger)

**Fix: Database Trigger**
```sql
-- See optimizations_20251006-142644.md lines 136-172

CREATE OR REPLACE FUNCTION calculate_booking_price()
RETURNS TRIGGER AS $$
DECLARE
  v_price_per_hour DECIMAL(10,2);
  v_duration_hours DECIMAL(10,2);
BEGIN
  SELECT price_per_hour INTO v_price_per_hour
  FROM parking_slots WHERE slot_id = NEW.slot_id;

  v_duration_hours := EXTRACT(EPOCH FROM (NEW.end_time - NEW.start_time)) / 3600;

  NEW.total_price := v_price_per_hour * v_duration_hours;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER booking_price_calculation
  BEFORE INSERT OR UPDATE OF start_time, end_time, slot_id ON bookings
  FOR EACH ROW EXECUTE FUNCTION calculate_booking_price();
```

Then remove `total_price` from client INSERT:
```typescript
// Client no longer sends total_price
result = AWAIT supabase
  .from('bookings')
  .insert({
    slot_id, renter_id, start_time, end_time, status: 'pending'
    // total_price auto-calculated by trigger
  })
```

---

#### 3. RLS Policy Performance (Subquery Hell)

**Problem:**
- `users_see_relevant_bookings` policy uses subquery
- Subquery executed for EVERY row
- 40-60% slower queries

**Affected Files:**
- `db/schema_refined.sql:169-177`

**Current Policy:**
```sql
CREATE POLICY "users_see_relevant_bookings" ON bookings
  FOR SELECT USING (
    auth.uid() = renter_id
    OR auth.uid() IN (
      SELECT owner_id FROM parking_slots WHERE slot_id = bookings.slot_id
    )
  );
```

**Fix: Denormalize owner_id**

See `optimizations_20251006-142644.md` lines 82-129 for complete implementation.

Summary:
1. Add column: `ALTER TABLE bookings ADD COLUMN slot_owner_id UUID`
2. Backfill: `UPDATE bookings SET slot_owner_id = ...`
3. Add trigger to auto-populate on INSERT
4. Replace policy with: `auth.uid() = renter_id OR auth.uid() = slot_owner_id`

---

#### 4. No Email Verification

**Problem:**
- Anyone can register with any email
- No proof of email ownership

**Affected Files:**
- `app/api/auth/signup/route.ts`

**Current Code:**
```typescript
email_confirm: true,  // Auto-confirm (INSECURE)
```

**Fix:**
```typescript
// Step 1: Disable auto-confirm
const { data, error } = await supabaseAdmin.auth.admin.createUser({
  email,
  password,
  email_confirm: false,  // Require verification
  user_metadata: { name, unit_number }
})

// Step 2: Supabase will send verification email automatically

// Step 3: User clicks link in email â†’ redirects to app

// Step 4: Handle callback
// app/auth/callback/route.ts
export async function GET(request: NextRequest) {
  const code = request.nextUrl.searchParams.get('code')

  if (code) {
    const supabase = createServerClient()
    await supabase.auth.exchangeCodeForSession(code)
  }

  return NextResponse.redirect(new URL('/slots', request.url))
}
```

---

#### 5. No Middleware Protection

**Problem:**
- All auth checks are client-side
- Can bypass by disabling JavaScript or using curl
- Unauthenticated users can hit API routes

**Fix: Create middleware.ts**

See `authentication_20251006-142644.md` lines 273-302.

```typescript
// middleware.ts
import { createServerClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  const supabase = createServerClient()
  const { data: { session } } = await supabase.auth.getSession()

  // Redirect unauthenticated users to login
  if (!session && !request.nextUrl.pathname.startsWith('/login')) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // Redirect authenticated users away from auth pages
  if (session && request.nextUrl.pathname.startsWith('/login')) {
    return NextResponse.redirect(new URL('/slots', request.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|public).*)',
  ]
}
```

---

### ğŸ”¥ High Priority Refactors

#### 6. Add updated_at Columns

**See:** `optimizations_20251006-142644.md` lines 213-250

Benefits:
- Audit trail for changes
- ETag support for caching
- Helps debugging

```sql
ALTER TABLE user_profiles ADD COLUMN updated_at TIMESTAMPTZ;
ALTER TABLE parking_slots ADD COLUMN updated_at TIMESTAMPTZ;
ALTER TABLE bookings ADD COLUMN updated_at TIMESTAMPTZ;

-- Backfill
UPDATE user_profiles SET updated_at = created_at;
UPDATE parking_slots SET updated_at = created_at;
UPDATE bookings SET updated_at = created_at;

-- Auto-update trigger
CREATE TRIGGER user_profiles_updated_at
  BEFORE UPDATE ON user_profiles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- Repeat for other tables
```

---

#### 7. Add Composite Index for Bookings

**See:** `optimizations_20251006-142644.md` lines 53-78

50-80% faster "my bookings" queries:

```sql
CREATE INDEX idx_bookings_renter_status_time
ON bookings(renter_id, status, start_time DESC)
WHERE status != 'cancelled';
```

---

#### 8. Add Rate Limiting

**See:** `authentication_20251006-142644.md` lines 329-364

Prevent brute force attacks:

```typescript
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(5, '1 h'),
})

// In login/signup route:
const ip = request.ip ?? '127.0.0.1'
const { success } = await ratelimit.limit(ip)

if (!success) {
  return NextResponse.json({ error: 'Too many requests' }, { status: 429 })
}
```

---

## Architecture Improvements

### Current Architecture Gaps

1. **No API Layer**
   - Business logic scattered in pages
   - No reusable functions
   - Hard to test

   **Fix:** Create `/lib/api/` with domain logic
   ```
   lib/api/
   â”œâ”€â”€ bookings.ts    (createBooking, cancelBooking, etc.)
   â”œâ”€â”€ slots.ts       (listSlots, createSlot, etc.)
   â””â”€â”€ users.ts       (getProfile, updateProfile, etc.)
   ```

2. **No Error Boundary**
   - Crashes show blank page
   - No user-friendly error messages

   **Fix:** See existing `components/ErrorBoundary.tsx`

3. **No Loading States**
   - Instant transitions feel broken
   - User doesn't know if app is working

   **Fix:** Consistent loading patterns everywhere

4. **No Caching**
   - Refetch same data on every navigation
   - Slow UX, wastes bandwidth

   **Fix:** React Query or SWR
   ```typescript
   import { useQuery } from '@tanstack/react-query'

   function SlotsPage() {
     const { data: slots, isLoading } = useQuery({
       queryKey: ['slots'],
       queryFn: fetchSlots,
       staleTime: 60000  // Cache for 1 minute
     })
   }
   ```

---

## Conclusion

This pseudocode represents the current state of ParkBoard with inline documentation of design decisions and refactoring recommendations.

**Priority Order:**
1. Fix schema mismatches (critical)
2. Implement database triggers for security (critical)
3. Add middleware protection (critical)
4. Optimize RLS policies (high)
5. Add rate limiting (high)
6. Implement remaining TODOs in Navigation (medium)
7. Add advanced features (low)

**Next Steps:**
1. Create GitHub issues from refactoring recommendations
2. Implement critical fixes (items 1-3)
3. Run tests from tests_20251007-090752.md
4. Deploy to staging
5. Implement high-priority items (4-5)
6. Production deployment

---

**Document Version:** 1.0
**Last Updated:** 2025-10-07
**Lines of Pseudocode:** ~2,500
**Critical Issues Identified:** 5
**High Priority Refactors:** 3
**Total Recommendations:** 30+
